<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ãƒ­ãƒ¼ãƒå­—ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’ï¼ˆè¨“ä»¤å¼ï¼‹åŒºåˆ†é¸æŠï¼‹è¨˜å·ï¼‹æ—¥æœ¬èªKBï¼‰</title>
<style>
:root{
  --bg:#d4dbea;
  --panel:#f5f7fb;
  --panel-2:#f5f7fb;
  --text:#111827;
  --muted:#4b5563;
  --accent:#1d4ed8;
  --ok:#15803d;
  --err:#b91c1c;
}
*{box-sizing:border-box}
body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font-family:system-ui,"Hiragino Sans","Noto Sans JP",Meiryo,sans-serif;
}
.wrap{
  max-width:980px;
  margin:24px auto;
  padding:16px;
}
.card{
  background:var(--panel);
  border:1px solid #c1c9da;
  border-radius:16px;
  box-shadow:0 4px 14px rgba(15,23,42,.12);
}
.section{
  padding:20px 22px;
  border-top:1px solid #dde3f1;
}
.section:first-child{border-top:0}
h1{margin:0 0 8px;font-size:28px;}
p.lead{color:var(--muted);margin:0 0 16px}
button{
  border:0;
  border-radius:12px;
  padding:12px 20px;
  font-weight:700;
  background:linear-gradient(180deg,#3b82f6,#1d4ed8);
  color:#fff;
  cursor:pointer;
}
button.secondary{
  background:linear-gradient(180deg,#e5e7eb,#c7d2fe);
  color:#111827;
}
button.ghost{
  background:#f9fafb;
  border:1px solid #c1c9da;
  color:#1f2933;
}
button+button{margin-left:10px}
.grid{display:grid;gap:16px}
.mono{font-family:ui-monospace,Consolas,"Noto Sans Mono",monospace}
.problemMeta{font-weight:700;color:#111827}

/* å•é¡Œæ–‡ãƒ»ã²ã‚‰ãŒãªï¼‹ãŠæ‰‹æœ¬ã¯ç™½èƒŒæ™¯ */
.problemBlock{
  background:#ffffff !important;
  color:#000000 !important;
  white-space:pre-wrap;
  overflow-wrap:anywhere;
  word-break:normal;
  line-height:1.6;
}

.tehon{font-size:22px;}
.tehon .done{color:#1d4ed8}
.tehon .todo{color:#4b5563}
.alarm{color:var(--err);font-weight:700;margin:6px 0 0}

.kbdWrap{display:flex;flex-direction:column;gap:12px}

/* ç™½ã‚«ãƒ¼ãƒ‰ç³»ï¼ˆå•é¡Œæ–‡ãƒ»çµæœï¼‰ã¯ç™½èƒŒæ™¯ */
.card,
.resultRow{
  background:#ffffff;
  border:1px solid #c1c9da;
  box-shadow:0 2px 6px rgba(15,23,42,.08);
}

/* ã²ã‚‰ãŒãªï¼‹ãŠæ‰‹æœ¬ã®æ ã‚’æ¶ˆã™ï¼ˆèƒŒæ™¯ãƒ»æ ãƒ»å½±ãªã—ï¼‰ */
.compactFrame{
  padding:8px 12px !important;
  border-radius:10px;
  background:transparent !important;
  border:none !important;
  box-shadow:none !important;
}
.compactStack{display:grid;grid-template-rows:auto auto;row-gap:4px;}
.compactTehon{font-size:calc(22px - 2pt - 1px);}
.compactFrame .tehon span{color:#000000;}
.compactFrame .tehon .done{color:#1d4ed8 !important;}

/* SVGç”¨ã‚³ãƒ³ãƒ†ãƒŠï¼šæ ç·šãƒ»å½±ãªã—ã€ä½™ç™½ã ã‘ */
.svgBox{
  background:transparent;
  border:none;
  box-shadow:none;
  border-radius:0;
  padding:8px;
}
.centerBox{display:flex;justify-content:center;align-items:center}

.footerBtns{display:flex;gap:10px;flex-wrap:wrap}
.startCenter{min-height:40vh;display:flex;align-items:center;justify-content:center;text-align:center;}
.small{font-size:13px;color:#4b5563}
.resultRow{padding:10px;border-radius:10px;background:#ffffff}
.bad{color:var(--err);font-weight:700}
.ok{color:#15803d}

/* æŠ˜ã‚Šè¿”ã—ã§å…¨æ–‡è¡¨ç¤ºï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ç„¡ã—ï¼‰ */
.growWrap{
  line-height:1.6;
  white-space:pre-wrap;
  overflow-wrap:anywhere;
  word-break:normal;
  overflow:visible;
}

/* å³ä¸Šã®çµŒéæ™‚é–“è¡¨ç¤º */
#app{position:relative;}
.elapsedTop{
  position:absolute; top:8px; right:12px;
  color:#111827;
  font-size:14px; line-height:1;
  background:#f9fafbcc;
  border:1px solid #c1c9da;
  padding:5px 10px; border-radius:999px;
  box-shadow:0 2px 4px rgba(107,114,128,.5);
  font-family:ui-monospace,Consolas,"Noto Sans Mono",monospace;
}

/* ãƒãƒ¼ãƒŸã‚¹è¡¨è¨˜ï¼ˆé’ãƒ»ã‚„ã‚„å¤§ãã‚ï¼‰ */
.noMiss{
  color:#1d4ed8;
  font-weight:700;
  font-size:1.08em;
  margin-left:8px;
}

/* ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ã®åŒºåˆ†é¸æŠï¼ˆã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹ï¼‰ */
.modeSelect{
  margin:8px 0 16px;
  display:flex;
  justify-content:center;
}
.modeSelect select{
  font-size:14px;
  padding:6px 10px;
  border-radius:8px;
  border:1px solid #c1c9da;
  background:#ffffff;
  color:#111827;
}

/* ã‚­ãƒ¼ãƒ©ãƒ™ãƒ«ï¼ˆä¸Šæ®µï¼è¨˜å·ã€å°ã•ã‚ / ä¸‹æ®µï¼ãƒ™ãƒ¼ã‚¹æ–‡å­—ï¼‰ */
.key-label-top{
  font-size:11px;
}
.key-label-bottom{
  font-size:13px;
}
</style>
</head>
<body>
<div class="wrap">
  <div id="app" class="card"></div>
</div>

<script>
/* =========================
   åŒºåˆ†ã”ã¨ã®è¨­å®š
========================= */

const MODE_WORD  = "word";   // å˜èª
const MODE_SHORT = "short";  // çŸ­æ–‡
const MODE_LONG  = "long";   // é•·æ–‡

/** å‡ºé¡Œæ•°ï¼ˆå¿…è¦ã«å¿œã˜ã¦å¤‰æ›´ï¼‰ */
const QUESTION_COUNT = {
  [MODE_WORD]:  2,
  [MODE_SHORT]: 2,
  [MODE_LONG]:  2
};

/** åŒºåˆ†ã”ã¨ã®å•é¡Œãƒ—ãƒ¼ãƒ« */
const WORD_PROBLEMS = [
  { kanji:"è¦ä»¶äº‹å®Ÿ",     hira:"ã‚ˆã†ã‘ã‚“ã˜ã˜ã¤" },
  { kanji:"è¡Œæ”¿æ³•",       hira:"ãã‚‡ã†ã›ã„ã»ã†" },
  { kanji:"è¨´è¨Ÿè¦ä»¶",     hira:"ãã—ã‚‡ã†ã‚ˆã†ã‘ã‚“" },
];

const SHORT_PROBLEMS = [
  { kanji:"è¦ä»¶äº‹å®Ÿã‚’æ•´ç†ã™ã‚‹ã€‚", hira:"ã‚ˆã†ã‘ã‚“ã˜ã˜ã¤ã‚’ã›ã„ã‚Šã™ã‚‹ã€‚" },
  { kanji:"è¡Œæ”¿ã®è£é‡ã¯é™ç•ŒãŒã‚ã‚‹ã€‚", hira:"ãã‚‡ã†ã›ã„ã®ã•ã„ã‚Šã‚‡ã†ã¯ã’ã‚“ã‹ã„ãŒã‚ã‚‹ã€‚" },
];

const LONG_PROBLEMS = [
  { kanji:"æ°‘æ³•ã®è¦ä»¶äº‹å®Ÿã¯æ¡æ–‡ã¨åˆ¤ä¾‹ã®ç†è§£ãŒä¸å¯æ¬ ã§ã‚ã‚‹ã€‚",
    hira :"ã¿ã‚“ã½ã†ã®ã‚ˆã†ã‘ã‚“ã˜ã˜ã¤ã¯ã˜ã‚‡ã†ã¶ã‚“ã¨ã¯ã‚“ã‚Œã„ã®ã‚Šã‹ã„ãŒãµã‹ã‘ã¤ã§ã‚ã‚‹ã€‚" },
  { kanji:"ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã¯å§¿å‹¢ã¨ãƒ›ãƒ¼ãƒ ãƒã‚¸ã‚·ãƒ§ãƒ³ã‚’å®ˆã‚‹ã“ã¨ãŒä¸Šé”ã¸ã®è¿‘é“ã ã€‚",
    hira :"ãŸã„ã´ã‚“ãã¯ã—ã›ã„ã¨ã»ãƒ¼ã‚€ã½ã˜ã—ã‚‡ã‚“ã‚’ã¾ã‚‚ã‚‹ã“ã¨ãŒã˜ã‚‡ã†ãŸã¤ã¸ã®ã¡ã‹ã¿ã¡ã ã€‚" },
];

const PROBLEM_POOLS = {
  [MODE_WORD]: WORD_PROBLEMS,
  [MODE_SHORT]: SHORT_PROBLEMS,
  [MODE_LONG]: LONG_PROBLEMS
};

/* =========================
   ã‹ãªâ†’ãƒ­ãƒ¼ãƒå­—ï¼ˆè¨“ä»¤å¼ï¼‹æºã‚Œï¼‹è¨˜å·ï¼‰
========================= */
const KUNREI = {
  "ã‚":"a","ã„":"i","ã†":"u","ãˆ":"e","ãŠ":"o",
  "ã‹":"ka","ã":"ki","ã":"ku","ã‘":"ke","ã“":"ko",
  "ã•":"sa","ã—":"si","ã™":"su","ã›":"se","ã":"so",
  "ãŸ":"ta","ã¡":"ti","ã¤":"tu","ã¦":"te","ã¨":"to",
  "ãª":"na","ã«":"ni","ã¬":"nu","ã­":"ne","ã®":"no",
  "ã¯":"ha","ã²":"hi","ãµ":"hu","ã¸":"he","ã»":"ho",
  "ã¾":"ma","ã¿":"mi","ã‚€":"mu","ã‚":"me","ã‚‚":"mo",
  "ã‚„":"ya","ã‚†":"yu","ã‚ˆ":"yo",
  "ã‚‰":"ra","ã‚Š":"ri","ã‚‹":"ru","ã‚Œ":"re","ã‚":"ro",
  "ã‚":"wa","ã‚’":"wo","ã‚“":"n",
  "ãŒ":"ga","ã":"gi","ã":"gu","ã’":"ge","ã”":"go",
  "ã–":"za","ã˜":"zi","ãš":"zu","ãœ":"ze","ã":"zo",
  "ã ":"da","ã¢":"di","ã¥":"du","ã§":"de","ã©":"do",
  "ã°":"ba","ã³":"bi","ã¶":"bu","ã¹":"be","ã¼":"bo",
  "ã±":"pa","ã´":"pi","ã·":"pu","ãº":"pe","ã½":"po",

  /* æ‹—éŸ³ */
  "ãã‚ƒ":"kya","ãã‚…":"kyu","ãã‚‡":"kyo",
  "ãã‚ƒ":"gya","ãã‚…":"gyu","ãã‚‡":"gyo",
  "ã—ã‚ƒ":"sya","ã—ã‚…":"syu","ã—ã‚‡":"syo",
  "ã˜ã‚ƒ":"zya","ã˜ã‚…":"zyu","ã˜ã‚‡":"zyo",
  "ã¡ã‚ƒ":"tya","ã¡ã‚…":"tyu","ã¡ã‚‡":"tyo",
  "ã«ã‚ƒ":"nya","ã«ã‚…":"nyu","ã«ã‚‡":"nyo",
  "ã²ã‚ƒ":"hya","ã²ã‚…":"hyu","ã²ã‚‡":"hyo",
  "ã³ã‚ƒ":"bya","ã³ã‚…":"byu","ã³ã‚‡":"byo",
  "ã´ã‚ƒ":"pya","ã´ã‚…":"pyu","ã´ã‚‡":"pyo",
  "ã¿ã‚ƒ":"mya","ã¿ã‚…":"myu","ã¿ã‚‡":"myo",
  "ã‚Šã‚ƒ":"rya","ã‚Šã‚…":"ryu","ã‚Šã‚‡":"ryo",

  /* æ•°å­— */
  "ï¼‘":"1","ï¼’":"2","ï¼“":"3","ï¼”":"4","ï¼•":"5",
  "ï¼–":"6","ï¼—":"7","ï¼˜":"8","ï¼™":"9","ï¼":"0",

  "ã€":",","ã€‚":".","ãƒ¼":"-",
  " ":" ","ã€€":" "
};

const VARIANTS = {
  "ã—": ["si","shi"],
  "ã¡": ["ti","chi"],
  "ã¤": ["tu","tsu"],
  "ãµ": ["hu","fu"],
  "ã˜": ["zi","ji"],
  "ã¢": ["di","ji"],
  "ã¥": ["du","zu"],
  "ã—ã‚ƒ": ["sya","sha"], "ã—ã‚…": ["syu","shu"], "ã—ã‚‡": ["syo","sho"],
  "ã˜ã‚ƒ": ["zya","ja"],  "ã˜ã‚…": ["zyu","ju"],  "ã˜ã‚‡": ["zyo","jo"],
  "ã¡ã‚ƒ": ["tya","cha","cya"], "ã¡ã‚…": ["tyu","chu","cyu"], "ã¡ã‚‡": ["tyo","cho","cyo"],
  "ã¢ã‚ƒ": ["dya","ja"], "ã¢ã‚…": ["dyu","ju"], "ã¢ã‚‡": ["dyo","jo"],
  "ãã‚ƒ": ["kya"], "ãã‚…": ["kyu"], "ãã‚‡": ["kyo"],
  "ãã‚ƒ": ["gya"], "ãã‚…": ["gyu"], "ãã‚‡": ["gyo"],
  "ã‚“": ["n","nn"]
};

/* å…¨è§’è¨˜å· â†’ åŠè§’è¨˜å·ï¼ˆæ—¥æœ¬èªã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å‰æï¼‰ */
const SYMBOL_MAP = {
  "ï¼":"!",
  "ï¼ƒ":"#",
  "ï¼„":"$",
  "ï¼…":"%",
  "ï¼†":"&",
  "ï¼ˆ":"(",
  "ï¼‰":")",
  "ï¼":"=",
  "ï½":"~",
  "ï¿¥":"\\",   // æ—¥æœ¬èªKBã®ã€Œï¿¥ã€ã‚­ãƒ¼ â†’ ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥
  "ï¼ ":"@",
  "ã€Œ":"[",
  "ã€":"]",
  "ï½›":"{",
  "ï½":"}",
  "ï¼›":";",
  "ï¼š":":",
  "ï¼‹":"+",
  "ï¼Š":"*",
  "ãƒ»":"/",   // ä¸­é»’ã¯ã¨ã‚Šã‚ãˆãš "/" ã«å‰²ã‚Šå½“ã¦ï¼ˆå¿…è¦ãªã‚‰å¤‰æ›´ï¼‰
  "ï¼Ÿ":"?",
  "ï¼":"/",
  "ï¼œ":"<",
  "ï¼":">",
  "ï¼¿":"_"
};
Object.assign(KUNREI, SYMBOL_MAP);

/* =========================
   ãƒˆãƒ¼ã‚¯ãƒŠã‚¤ã‚º
========================= */
function tokenizeHira(hira){
  const toks=[];
  for(let i=0;i<hira.length;i++){
    const pair = hira.slice(i,i+2);
    if(VARIANTS[pair] || KUNREI[pair]){ toks.push(pair); i++; continue; }
    toks.push(hira[i]);
  }
  return toks;
}
function romajiCandidates(token){
  if(token === "ã£") return [""];
  if(VARIANTS[token]) return [...VARIANTS[token]];
  if(KUNREI[token]!=null) return [KUNREI[token]];
  return [token];
}

/* =========================
   ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°NFAãƒãƒƒãƒãƒ£
========================= */
function startMatcher(hira){
  const toksAll = tokenizeHira(hira.replace(/\r\n?/g,"\n"));
  const skipRe = /[\s\u3000]/;
  const toks = toksAll.filter(t => !skipRe.test(t));

  let states = [];
  function dedup(arr){ const m=new Map(); for(const s of arr)m.set(`${s.ti}|${s.cur}|${s.pos}`,s); return [...m.values()]; }
  function initFrom(ti){
    if(ti>=toks.length){ states=[{ti,cur:"",pos:0}]; return; }
    const t=toks[ti];
    if(t==="ã£"){
      const nn=ti+1; if(nn>=toks.length){ states=[{ti:nn,cur:"",pos:0}]; return; }
      const cs=romajiCandidates(toks[nn]); states=dedup(cs.map(c=>({ti:nn,cur:(c[0]||"")+c,pos:0}))); return;
    }
    const cs=romajiCandidates(t); states=dedup(cs.map(c=>({ti,cur:c,pos:0})));
  }
  function advanceDone(arr){
    const out=[];
    for(const s of arr){
      if(s.pos < s.cur.length){ out.push(s); continue; }
      const nextTi=s.ti+1;
      if(nextTi>=toks.length){ out.push({ti:nextTi,cur:"",pos:0}); continue; }
      const t=toks[nextTi];
      if(t==="ã£"){
        const nn=nextTi+1; if(nn>=toks.length){ out.push({ti:nn,cur:"",pos:0}); continue; }
        const cs=romajiCandidates(toks[nn]); cs.forEach(c=>out.push({ti:nn,cur:(c[0]||"")+c,pos:0})); continue;
      }
      const cs=romajiCandidates(t); cs.forEach(c=>out.push({ti:nextTi,cur:c,pos:0}));
    }
    return dedup(out);
  }

  initFrom(0);

  let typed=""; const stream=[];
  function step(ch){
    const low = ch.toLowerCase();
    const next=[];
    for(const s of states){ const need=s.cur[s.pos]||""; if(need && need.toLowerCase()===low){ next.push({...s,pos:s.pos+1}); } }
    if(next.length===0){ stream.push({ch,ok:false}); return {ok:false,done:false}; }
    typed += ch; stream.push({ch,ok:true}); states = advanceDone(next);
    return {ok:true,done:isDone()};
  }
  function isDone(){ return states.length>0 && states.every(s=> (s.ti>=toks.length) && (s.pos>=s.cur.length)); }
  function candidatesNextChars(){ const set=new Set(); for(const s of states){ const need=s.cur[s.pos]; if(need) set.add(need.toLowerCase()); } return [...set]; }
  function representSolution(){
    if(states.length===0) return typed;
    const s0 = [...states].sort((a,b)=>(a.cur.length-a.pos)-(b.cur.length-b.pos))[0];
    let out = typed + s0.cur.slice(s0.pos);
    let ti = s0.ti + 1;
    while(ti < toks.length){
      const t = toks[ti];
      if(t==="ã£"){ const t2=toks[ti+1]; if(!t2) break; const c2=romajiCandidates(t2)[0]||""; out += (c2[0]||"")+c2; ti+=2; continue; }
      out += (romajiCandidates(t)[0]||""); ti++;
    }
    return out;
  }
  return { step, isDone, candidatesNextChars, representSolution, getTyped:()=>typed, getStream:()=>stream };
}

/* =========================
   ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ï¼†æŒ‡SVGï¼ˆæ—¥æœ¬èªã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å¯„ã›ï¼‰
========================= */

/* å„ã‚­ãƒ¼ï¼šbase=é€šå¸¸ã€shift=è¨˜å·ï¼ˆJISé¢¨ï¼‰ */
const KEY_ROWS = [
  {
    offset:0,
    keys:[
      {base:"1", shift:"!"},
      {base:"2", shift:"\""},
      {base:"3", shift:"#"},
      {base:"4", shift:"$"},
      {base:"5", shift:"%"},
      {base:"6", shift:"&"},
      {base:"7", shift:"'"},
      {base:"8", shift:"("},
      {base:"9", shift:")"},
      {base:"0", shift:""},
      {base:"-", shift:"_"},
      {base:"^", shift:"~"},
      {base:"\\", shift:"|"}  // JIS ã®ã€Œï¿¥ã€ã‚­ãƒ¼ã‚’ \ / | ã§è¿‘ä¼¼
    ]
  },
  {
    offset:18,
    keys:[
      {base:"q", shift:""},
      {base:"w", shift:""},
      {base:"e", shift:""},
      {base:"r", shift:""},
      {base:"t", shift:""},
      {base:"y", shift:""},
      {base:"u", shift:""},
      {base:"i", shift:""},
      {base:"o", shift:""},
      {base:"p", shift:""},
      {base:"@", shift:"`"},
      {base:"[", shift:"{"}
    ]
  },
  {
    offset:28,
    keys:[
      {base:"a", shift:""},
      {base:"s", shift:""},
      {base:"d", shift:""},
      {base:"f", shift:""},
      {base:"g", shift:""},
      {base:"h", shift:""},
      {base:"j", shift:""},
      {base:"k", shift:""},
      {base:"l", shift:""},
      {base:";", shift:":"},
      {base:"]", shift:"}"}
    ]
  },
  {
    offset:40,
    keys:[
      {base:"z", shift:""},
      {base:"x", shift:""},
      {base:"c", shift:""},
      {base:"v", shift:""},
      {base:"b", shift:""},
      {base:"n", shift:""},
      {base:"m", shift:""},
      {base:",", shift:"<"},
      {base:".", shift:">"},
      {base:"/", shift:"?"}
    ]
  }
];

function renderKeyboardSVG(highlightChars){
  const hi = new Set(highlightChars.map(c=>c.toLowerCase()));
  const u=42, keyH=38, r=6, pad=10;
  const W = pad*2 + 14*u;
  const H = pad*2 + KEY_ROWS.length*(keyH+8);
  let y=pad, out=[];
  KEY_ROWS.forEach(row=>{
    let x=pad + row.offset;
    row.keys.forEach(key=>{
      const kBase = key.base;
      const kShift = key.shift || "";
      const active =
        hi.has(kBase.toLowerCase()) ||
        (kShift && hi.has(kShift.toLowerCase()));
      out.push(`
        <g>
          <rect x="${x}" y="${y}" rx="${r}" ry="${r}" width="${u-6}" height="${keyH-6}"
            fill="${active?'#c7d2fe':'#e5e7f5'}"
            stroke="${active?'#1d4ed8':'#9ca3af'}"
            stroke-width="${active?2:1}"></rect>
          ${
            kShift
            ? `<text x="${x+(u-6)/2}" y="${y+13}" text-anchor="middle"
                     class="mono key-label-top" fill="#111827">${kShift}</text>
               <text x="${x+(u-6)/2}" y="${y+keyH-11}" text-anchor="middle"
                     class="mono key-label-bottom" fill="#111827">${kBase}</text>`
            : `<text x="${x+(u-6)/2}" y="${y+keyH/2+5}" text-anchor="middle"
                     class="mono key-label-bottom" fill="#111827">${kBase}</text>`
          }
        </g>
      `);
      x+=u;
    });
    y+=keyH+8;
  });
  return `<svg viewBox="0 0 ${W} ${H}" width="100%" role="img" aria-label="Japanese keyboard (JIS-like)">
    ${out.join("")}
  </svg>`;
}

/* æŒ‡æ‹…å½“ï¼ˆ0=å·¦å°,1=å·¦è–¬,2=å·¦ä¸­,3=å·¦äºº,4=å³äºº,5=å³ä¸­,6=å³è–¬,7=å³å°ï¼‰ */
/* ãƒ™ãƒ¼ã‚¹ã‚­ãƒ¼ã®å‰²ã‚Šå½“ã¦ */
const FINGER_MAP = new Map();
"1qaaz".split("").forEach(c=>FINGER_MAP.set(c,0));          // å·¦å°
"2wsx".split("").forEach(c=>FINGER_MAP.set(c,1));           // å·¦è–¬
"3edc".split("").forEach(c=>FINGER_MAP.set(c,2));           // å·¦ä¸­
"45rtfgvb".split("").forEach(c=>FINGER_MAP.set(c,3));       // å·¦äºº
"67yuhjnm".split("").forEach(c=>FINGER_MAP.set(c,4));       // å³äºº
"8ik,".split("").forEach(c=>FINGER_MAP.set(c,5));           // å³ä¸­
"9ol.".split("").forEach(c=>FINGER_MAP.set(c,6));           // å³è–¬
"0p;/[]\\-'\"".split("").forEach(c=>FINGER_MAP.set(c.toLowerCase(),7)); // å³å°
FINGER_MAP.set("/",7); // ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚‚å³å°

/* Shiftå´ã®è¨˜å·ã¯ã€ãã®ãƒ™ãƒ¼ã‚¹ã‚­ãƒ¼ã¨åŒã˜æŒ‡ã«ã™ã‚‹ */
KEY_ROWS.forEach(row=>{
  row.keys.forEach(k=>{
    const base = k.base.toLowerCase();
    const shift = k.shift;
    if(shift){
      const f = FINGER_MAP.get(base);
      if(f!=null) FINGER_MAP.set(shift.toLowerCase(), f);
    }
  });
});

/* æŒ‡SVG */
function renderFingersSVG(highlightFingers){
  const hi = new Set(highlightFingers);
  const fingerNames = ["å·¦å°","å·¦è–¬","å·¦ä¸­","å·¦äºº","å³äºº","å³ä¸­","å³è–¬","å³å°"];

  const r = 16, bw = r*3, bh = r*3, gap = 12, mid = 60, pad = 12;
  const leftW = bw*4 + gap*3, rightW = leftW, groupW = leftW + mid + rightW;
  const W = groupW + pad*2, H = Math.max(64, bh + pad*2);
  const baseX = (W - groupW)/2, baseY = pad;

  const blocks=[];
  for(let i=0;i<8;i++){
    const x = (i<=3) ? (baseX + i*(bw+gap)) : (baseX + leftW + mid + (i-4)*(bw+gap));
    const y = baseY; const active = hi.has(i);
    blocks.push(`
      <g>
        <rect x="${x}" y="${y}" rx="${Math.max(6,r)}" ry="${Math.max(6,r)}"
              width="${bw}" height="${bh}"
              fill="${active?'#c7d2fe':'#e5e7ff'}"
              stroke="${active?'#1d4ed8':'#cbd5f5'}" stroke-width="1"></rect>
        <text x="${x + bw/2}" y="${y + bh/2 + 0.5}" text-anchor="middle"
              font-size="14" fill="#111827" dominant-baseline="middle">${fingerNames[i]}</text>
      </g>
    `);
  }
  return `
  <svg viewBox="0 0 ${W} ${H}" width="${W}" style="max-width:100%;height:auto"
       role="img" aria-label="Fingers (excluding thumbs)">
    ${blocks.join("")}
  </svg>`;
}

/* =========================
   ç”»é¢ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
========================= */
const app = document.getElementById("app");
let timerId = null;

function getSelectedMode(){
  const sel = document.getElementById("modeSelect");
  return sel ? sel.value : MODE_WORD;
}

const Screen = {
  start(){
    app.innerHTML = `
      <div id="elapsedTop" class="elapsedTop">0.0s</div>
      <div class="section startCenter">
        <div>
          <h1>ãƒ­ãƒ¼ãƒå­—ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ç·´ç¿’</h1>
          <p class="lead">åŒºåˆ†ã‚’é¸ã³ã€ã‚¹ã‚¿ãƒ¼ãƒˆã‚’æŠ¼ã™ã‹ Enter ã‚­ãƒ¼ã§é–‹å§‹ã—ã¾ã™ã€‚</p>

          <div class="small" style="margin-bottom:4px;text-align:center;">ç·´ç¿’åŒºåˆ†</div>
          <div class="modeSelect">
            <select id="modeSelect">
              <option value="${MODE_WORD}" selected>å˜èª</option>
              <option value="${MODE_SHORT}">çŸ­æ–‡</option>
              <option value="${MODE_LONG}">é•·æ–‡</option>
            </select>
          </div>

          <button id="btnStart">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        </div>
      </div>`;
    document.getElementById("btnStart").onclick = ()=>{
      const mode = getSelectedMode();
      Screen.countdown(() => Controller.beginSession(mode));
    };
    window.onkeydown = (e)=>{
      if(e.key==="Enter"){
        e.preventDefault();
        const mode = getSelectedMode();
        Screen.countdown(() => Controller.beginSession(mode));
      }
    };
  },

  // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ç”»é¢
  countdown(startFn){
    let count = 3;

    app.innerHTML = `
      <div id="elapsedTop" class="elapsedTop">0.0s</div>
      <div class="section startCenter">
        <div>
          <h1>æº–å‚™ã—ã¦ãã ã•ã„</h1>
          <p class="lead">ã¾ã‚‚ãªãé–‹å§‹ã—ã¾ã™...</p>
          <div id="countNum"
               style="font-size:60px;font-weight:700;text-align:center;margin-top:20px;">
            ${count}
          </div>
        </div>
      </div>
    `;

    // Enteré€£æ‰“ãªã©ã‚’ç„¡åŠ¹åŒ–
    window.onkeydown = null;

    const intervalId = setInterval(()=>{
      count--;
      const el = document.getElementById("countNum");
      if(el) el.textContent = count > 0 ? String(count) : "START";

      if(count <= 0){
        clearInterval(intervalId);
        if (typeof startFn === "function") {
          startFn();
        }
      }
    }, 1000);
  },

  // â˜… ã“ã“ã‚’æ”¹é€ ï¼šmode ã«ã‚ˆã£ã¦ã€Œã²ã‚‰ãŒãªã€è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
  question(state){
    const {
      index, total, kanji, hira, matcher,
      alarm, typedNow, nextKeys, nextFingers, mode
    } = state;

    // å˜èªãƒ¢ãƒ¼ãƒ‰ã®ã¨ãã ã‘ã²ã‚‰ãŒãªã‚’è¡¨ç¤º
    const showHira = (mode === MODE_WORD);

    let sol = matcher.representSolution();
    sol = fixEndingNForHira(hira, sol);   // ã“ã“ã§ã ã‘è£œæ­£ã™ã‚‹
    
    const htmlTehon =
      `<span class="done">${escapeHtml(typedNow)}</span>` +
      `<span class="todo">${escapeHtml(sol.slice(typedNow.length))}</span>`;

    app.innerHTML = `
      <div id="elapsedTop" class="elapsedTop">0.0s</div>

      <div class="section">
        <div class="problemMeta">ç¬¬${index+1}å• / å…¨${total}å•</div>
      </div>

      <div class="section grid">
        <div>
          <div class="small">å•é¡Œæ–‡ï¼ˆæ¼¢å­—ï¼‰</div>
          <div class="card problemBlock section growWrap">${escapeHtml(kanji)}</div>
        </div>

        <!-- ã²ã‚‰ãŒãªï¼‹ãŠæ‰‹æœ¬ï¼ˆå˜èªã®ã¨ãã ã‘ã²ã‚‰ãŒãªè¡¨ç¤ºï¼‰ -->
        <div>
          <div class="card section compactFrame">
            <div class="compactStack">
              ${
                showHira
                  ? `<div class="problemBlock growWrap">${escapeHtml(hira)}</div>`
                  : ``
              }
              <div class="mono tehon compactTehon growWrap" id="tehon">${htmlTehon}</div>
            </div>
          </div>
          <div id="alarm" class="alarm" style="visibility:${alarm?'visible':'hidden'}">ãƒŸã‚¹ã‚¿ã‚¤ãƒ—ã§ã™ï¼ˆæ­£ã—ã„ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼‰ã€‚</div>
          <div class="small" style="margin-top:6px">
            â€» ç©ºç™½ã¯å…¥åŠ›ä¸è¦ã€‚æ”¹è¡Œã¯ç„¡è¦–ã€‚ã€Œã€ã€ã¯ <span class="mono">,</span>ã€ã€Œã€‚ã€ã¯ <span class="mono">.</span>ã€‚å…¥åŠ›å¾Œã¯ <span class="mono">Enter</span> ã§å›ç­”ç¢ºå®šã€‚
          </div>
        </div>

        <div class="kbdWrap">
          <div class="small">ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒãƒƒãƒ—ï¼ˆæ—¥æœ¬èªé…åˆ—ï¼‰</div>
          <div class="svgBox" id="kbSvg">${renderKeyboardSVG(nextKeys)}</div>
          <div class="svgBox centerBox" id="finSvg">${renderFingersSVG(nextFingers)}</div>
        </div>
      </div>

      <div class="section footerBtns">
        <button class="ghost" id="btnBack">ã‚¹ã‚¿ãƒ¼ãƒˆã«æˆ»ã‚‹</button>
      </div>
    `;
    document.getElementById("btnBack").onclick = ()=> Screen.confirmBack();
    Controller.bindKeys();
  },

  confirmBack(){
    if(timerId){ clearInterval(timerId); timerId=null; }
    window.onkeydown = null;
    Screen.start();
  },

  result({records, elapsedMs, sameRetry, randomRetry}){
    const secs = (elapsedMs/1000).toFixed(2);
    const rows = records.map(r=>{
      const hasMistake = r.stream.some(ev=>!ev.ok);
      const mixt = highlightStream(r.stream);
      const title = `${escapeHtml(r.kanji)}${!hasMistake ? ' <span class="noMiss">ãƒãƒ¼ãƒŸã‚¹ï¼</span>' : ''}`;
      return `
      <div class="resultRow">
        <div class="small">å•é¡Œæ–‡</div>
        <div class="problemBlock growWrap">${title}</div>
        <div class="small" style="margin-top:6px">å…¥åŠ›ï¼ˆèª¤ã‚Šã¯èµ¤ï¼‰</div>
        <div class="mono growWrap">${mixt}</div>
      </div>`;
    }).join("");

    app.innerHTML = `
      <div id="elapsedTop" class="elapsedTop">${secs}s</div>

      <div class="section">
        <h1>çµæœ</h1>
        <p class="lead">æ‰€è¦æ™‚é–“ï¼š<strong>${secs} ç§’</strong></p>
      </div>
      <div class="section grid">
        ${rows || `<div class="small">å…¨å•ãƒŸã‚¹ã‚¿ã‚¤ãƒ—ãªã— ğŸ‰</div>`}
      </div>
      <div class="section footerBtns">
        <button id="btnSame">åŒã˜å•é¡Œã§å†æŒ‘æˆ¦</button>
        <button class="secondary" id="btnRandom">ãƒ©ãƒ³ãƒ€ãƒ å†æŒ‘æˆ¦</button>
        <button class="ghost" id="btnHome">ã‚¹ã‚¿ãƒ¼ãƒˆæˆ»ã‚Š</button>
      </div>
    `;
    document.getElementById("btnSame").onclick = ()=>Screen.countdown(sameRetry);
    document.getElementById("btnRandom").onclick = ()=>Screen.countdown(randomRetry);
    document.getElementById("btnHome").onclick = ()=> Screen.start();
  }
};

/* =========================
   ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©
========================= */
const Controller = (()=>{
  let session = null;

  function beginSession(mode){
    const modeKey = mode || MODE_WORD;
    const pool = PROBLEM_POOLS[modeKey] || WORD_PROBLEMS;
    const count = QUESTION_COUNT[modeKey] ?? 2;

    const normalized = pool.map(p=>({
      kanji: p.kanji.slice(0,300),
      hira:  p.hira.slice(0,300)
    }));

    const chosen = [...normalized]
      .sort(()=>Math.random()-0.5)
      .slice(0, Math.min(count, normalized.length));

    session = {
      mode: modeKey,
      problems: chosen,
      idx: 0,
      startAt: performance.now(),
      records: []
    };
    startQuestion();
  }

  function startQuestion(){
    const pr = session.problems[session.idx];
    const matcher = startMatcher(pr.hira);
    session.qstate = {
      index: session.idx,
      total: session.problems.length,
      kanji: pr.kanji,
      hira: pr.hira,
      matcher,
      typedNow: "",
      alarm:false,
      stream:[],
      mode: session.mode   // â˜… Screen.question ã« mode ã‚’æ¸¡ã™
    };

    if(timerId) clearInterval(timerId);
    timerId = setInterval(updateHighlights, 100);

    updateHighlights();
    Screen.question({
      ...session.qstate,
      nextKeys: nextKeyCandidates(),
      nextFingers: nextFingerCandidates()
    });
  }

  function nextKeyCandidates(){ return session.qstate.matcher.candidatesNextChars(); }
  function nextFingerCandidates(){
    const keys = nextKeyCandidates();
    const fingers=new Set();
    keys.forEach(k=>{
      const f = FINGER_MAP.get(k.toLowerCase());
      if(f!=null) fingers.add(f);
    });
    return [...fingers];
  }

  function updateHighlights(){
    const elTop = document.getElementById("elapsedTop");
    if(elTop && session){
      const sec = ((performance.now()-session.startAt)/1000).toFixed(1);
      elTop.textContent = `${sec}s`;
    }
    const elKb = document.getElementById("kbSvg");
    const elFi = document.getElementById("finSvg");
    if(session && elKb) elKb.innerHTML = renderKeyboardSVG(nextKeyCandidates());
    if(session && elFi) elFi.innerHTML = renderFingersSVG(nextFingerCandidates());
  }

  function bindKeys(){
    window.onkeydown = (e)=>{
      if(!session) return;
      const q = session.qstate;

      if(e.key==="Enter"){
        e.preventDefault();
        if(q.matcher.isDone()){
          finalizeQuestion();
        }else{
          flashAlarm();
        }
        return;
      }
      if(e.ctrlKey || e.metaKey || e.altKey) return;
      if(e.key.length!==1) return;

      const key = normalizeKey(e.key);
      const r = q.matcher.step(key);
      if(r.ok){
        q.typedNow = q.matcher.getTyped();
        q.stream = q.matcher.getStream();
        q.alarm=false;
        Screen.question({
          ...q,
          nextKeys: nextKeyCandidates(),
          nextFingers: nextFingerCandidates()
        });
      }else{
        q.alarm=true;
        const alarmEl=document.getElementById("alarm");
        if(alarmEl) alarmEl.style.visibility="visible";
        flashAlarm();
      }
      updateHighlights();
    };
  }

  function flashAlarm(){
    const a = document.getElementById("alarm"); if(!a) return;
    a.animate(
      [{transform:"scale(1)"},{transform:"scale(1.03)"},{transform:"scale(1)"}],
      {duration:220}
    );
  }

  function finalizeQuestion(){
    const q = session.qstate;
    session.records.push({
      kanji: q.kanji,
      typedFinal: q.matcher.representSolution(),
      stream: q.stream
    });
    session.idx++;
    if(session.idx < session.problems.length){
      startQuestion();
    }else{
      if(timerId){ clearInterval(timerId); timerId=null; }
      const elapsedMs = performance.now() - session.startAt;
      Screen.result({
        records: session.records,
        elapsedMs,
        sameRetry: ()=>{
          session.idx=0;
          session.records=[];
          session.startAt=performance.now();
          startQuestion();
        },
        randomRetry: ()=> beginSession(session.mode)
      });
      window.onkeydown = null;
    }
  }

  return { beginSession, bindKeys };
})();

/* =========================
   ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
========================= */
function escapeHtml(s){
  return (s+"").replace(/[&<>"']/g,m=>(
    {"&":"&amp;","<":"&lt;",">":"&quot;","'":"&#39;"}[m]
  ));
}
function normalizeKey(k){
  const low = k.toLowerCase();
  if(low==="ã€") return ",";
  if(low==="ã€‚") return ".";
  return low;
}
function highlightStream(stream){
  let out="";
  for(const ev of stream){
    out += ev.ok
      ? `<span>${escapeHtml(ev.ch)}</span>`
      : `<span class="bad">${escapeHtml(ev.ch)}</span>`;
  }
  return out;
}

// ã€ŒãŠæ‰‹æœ¬ã€è¡¨ç¤ºå°‚ç”¨ï¼šæœ«å°¾ãŒã€Œã‚“ã€ã®å ´åˆã ã‘ nn ã«è£œæ­£ã€‚
// ã™ã§ã« nn ãªã‚‰ä½•ã‚‚ã—ãªã„ã€‚
function fixEndingNForHira(hira, roma) {
  // ç©ºç™½ãƒ»å…¨è§’ã‚¹ãƒšãƒ¼ã‚¹ã¯ç„¡è¦–ã—ã¦åˆ¤å®š
  const hiraNoSpace = hira.replace(/[\s\u3000]/g, "");
  if (!hiraNoSpace.endsWith("ã‚“")) return roma;

  // ã™ã§ã« nn ã§çµ‚ã‚ã£ã¦ã„ã‚Œã°ãã®ã¾ã¾
  if (roma.endsWith("nn")) return roma;

  // n ã§çµ‚ã‚ã£ã¦ã„ã‚Œã° nn ã«ã™ã‚‹
  if (roma.endsWith("n")) return roma + "n";

  return roma;
}

/* èµ·å‹• */
Screen.start();
</script>
</body>
</html>
